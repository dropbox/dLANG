//! TLA+ Specification Generator
//!
//! This module generates actual TLA+ specifications from TLA2Model.
//! The output can be used directly with TLA+ tools like TLC model checker.
//!
//! Phase 5 of DIRECTIVE_TLA_EXTRACT.

use crate::model::{BinOp, CompareOp, Expr, Predicate, TLA2Model, Transition, UnaryOp, VarType};
use std::fmt::Write;

/// Generate a complete TLA+ specification from a TLA2Model
#[must_use]
pub fn generate_tla2_spec(model: &TLA2Model) -> String {
    let mut spec = String::new();

    // Module header
    let _ = writeln!(
        spec,
        "---- MODULE {} ----",
        sanitize_module_name(&model.name)
    );
    spec.push_str("\\* Generated by tRust tla-extract\n");
    spec.push_str("\\* This specification was automatically extracted from Rust async code\n\n");

    // EXTENDS
    spec.push_str("EXTENDS Integers, Sequences, TLC\n\n");

    // CONSTANTS (if needed)
    let max_state = model
        .terminal_states
        .iter()
        .map(|s| s.0)
        .max()
        .unwrap_or(model.transitions.len());
    let _ = writeln!(spec, "CONSTANT MaxState \\* Default: {max_state}\n");

    // VARIABLES section
    spec.push_str("VARIABLES ");
    let var_names: Vec<&str> = model.variables.iter().map(|v| v.name.as_str()).collect();
    spec.push_str(&var_names.join(", "));
    spec.push_str("\n\n");

    // Variable tuple (for TLC)
    spec.push_str("vars == <<");
    spec.push_str(&var_names.join(", "));
    spec.push_str(">>\n\n");

    // TypeInvariant
    spec.push_str("TypeInvariant ==\n");
    for var in &model.variables {
        let type_pred = var_type_to_tla2(&var.name, &var.ty);
        let _ = writeln!(spec, "    /\\ {type_pred}");
    }
    spec.push('\n');

    // Init
    spec.push_str("Init ==\n");
    let _ = writeln!(spec, "    {}\n", predicate_to_tla2(&model.init));

    // Actions (transitions)
    for trans in &model.transitions {
        spec.push_str(&transition_to_tla2(trans));
        spec.push('\n');
    }

    // Next
    spec.push_str("Next ==\n");
    if model.transitions.is_empty() {
        spec.push_str("    FALSE \\* No transitions\n");
    } else {
        for (i, trans) in model.transitions.iter().enumerate() {
            if i == 0 {
                let _ = writeln!(spec, "    {}", trans.name);
            } else {
                let _ = writeln!(spec, "    \\/ {}", trans.name);
            }
        }
    }
    spec.push('\n');

    // Stuttering step (for liveness)
    spec.push_str("Spec == Init /\\ [][Next]_vars\n\n");

    // Termination property (eventually reach terminal state)
    if !model.terminal_states.is_empty() {
        spec.push_str("\\* Termination: eventually reach a terminal state\n");
        spec.push_str("Termination ==\n");
        spec.push_str("    <>(");
        let terminal_preds: Vec<String> = model
            .terminal_states
            .iter()
            .map(|s| format!("_pc = {}", s.0))
            .collect();
        spec.push_str(&terminal_preds.join(" \\/ "));
        spec.push_str(")\n\n");
    }

    // Safety property (no deadlock except at terminal)
    spec.push_str("\\* Safety: if not terminal, some action is enabled\n");
    spec.push_str("NoDeadlock ==\n");
    if model.terminal_states.is_empty() {
        spec.push_str("    ENABLED Next\n");
    } else {
        spec.push_str("    (");
        let terminal_preds: Vec<String> = model
            .terminal_states
            .iter()
            .map(|s| format!("_pc = {}", s.0))
            .collect();
        spec.push_str(&terminal_preds.join(" \\/ "));
        spec.push_str(") \\/ ENABLED Next\n");
    }
    spec.push('\n');

    // Footer
    spec.push_str("====\n");

    spec
}

/// Sanitize module name for TLA+
fn sanitize_module_name(name: &str) -> String {
    name.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

/// Convert VarType to TLA+ type predicate
fn var_type_to_tla2(name: &str, ty: &VarType) -> String {
    match ty {
        VarType::Bool => format!("{name} \\in BOOLEAN"),
        VarType::Int { bits, signed } => {
            if *signed {
                let bits_u32 = u32::from(*bits);
                if bits_u32 == 0 {
                    return format!("{name} \\in Int");
                }
                if bits_u32 >= 128 {
                    format!("{} \\in {}..{}", name, i128::MIN, i128::MAX)
                } else {
                    let shift = bits_u32 - 1;
                    let min: i128 = -(1i128 << shift);
                    let max: i128 = (1i128 << shift) - 1;
                    format!("{name} \\in {min}..{max}")
                }
            } else {
                let bits_u32 = u32::from(*bits);
                if bits_u32 == 0 {
                    return format!("{name} \\in Nat");
                }
                let max: u128 = if bits_u32 >= 128 {
                    u128::MAX
                } else {
                    (1u128 << bits_u32) - 1
                };
                format!("{name} \\in 0..{max}")
            }
        }
        VarType::Enum {
            name: _enum_name,
            variants,
        } => {
            let variant_strs: Vec<String> = variants.iter().map(|v| format!("\"{v}\"")).collect();
            format!("{} \\in {{{}}}", name, variant_strs.join(", "))
        }
        VarType::Tuple(elems) => {
            // Tuple as sequence
            format!("{} \\in Seq(Int) /\\ Len({}) = {}", name, name, elems.len())
        }
        VarType::Array { elem: _, len } => {
            format!("{name} \\in [1..{len} -> Int]")
        }
        VarType::Set(elem) => {
            let elem_domain = var_type_domain(elem);
            format!("{name} \\subseteq {elem_domain}")
        }
        VarType::Map { key, value: _ } => {
            let key_domain = var_type_domain(key);
            format!("{name} \\in [{key_domain} -> Int]")
        }
        VarType::Opaque(type_name) => {
            // Opaque types are modeled as natural numbers (abstract)
            format!("{name} \\in Nat \\* opaque: {type_name}")
        }
    }
}

/// Get the domain for a type (for set/map comprehensions)
fn var_type_domain(ty: &VarType) -> String {
    match ty {
        VarType::Bool => "BOOLEAN".to_string(),
        VarType::Int { bits: _, signed: _ } => "Int".to_string(),
        _ => "Nat".to_string(),
    }
}

/// Convert Predicate to TLA+ expression
fn predicate_to_tla2(pred: &Predicate) -> String {
    match pred {
        Predicate::Bool(true) => "TRUE".to_string(),
        Predicate::Bool(false) => "FALSE".to_string(),
        Predicate::Var(v) => v.clone(),
        Predicate::Compare { left, op, right } => {
            let op_str = match op {
                CompareOp::Eq => "=",
                CompareOp::Ne => "#",
                CompareOp::Lt => "<",
                CompareOp::Le => "<=",
                CompareOp::Gt => ">",
                CompareOp::Ge => ">=",
            };
            format!("{} {} {}", expr_to_tla2(left), op_str, expr_to_tla2(right))
        }
        Predicate::Not(p) => format!("~({})", predicate_to_tla2(p)),
        Predicate::And(preds) => {
            if preds.is_empty() {
                "TRUE".to_string()
            } else {
                let parts: Vec<String> = preds.iter().map(predicate_to_tla2).collect();
                format!("({})", parts.join(" /\\ "))
            }
        }
        Predicate::Or(preds) => {
            if preds.is_empty() {
                "FALSE".to_string()
            } else {
                let parts: Vec<String> = preds.iter().map(predicate_to_tla2).collect();
                format!("({})", parts.join(" \\/ "))
            }
        }
        Predicate::Implies(lhs, rhs) => {
            format!(
                "({}) => ({})",
                predicate_to_tla2(lhs),
                predicate_to_tla2(rhs)
            )
        }
        Predicate::In { elem, set } => {
            format!("{} \\in {}", expr_to_tla2(elem), expr_to_tla2(set))
        }
        Predicate::ForAll { var, domain, body } => {
            format!(
                "\\A {} \\in {}: {}",
                var,
                expr_to_tla2(domain),
                predicate_to_tla2(body)
            )
        }
        Predicate::Exists { var, domain, body } => {
            format!(
                "\\E {} \\in {}: {}",
                var,
                expr_to_tla2(domain),
                predicate_to_tla2(body)
            )
        }
    }
}

/// Convert Expr to TLA+ expression
fn expr_to_tla2(expr: &Expr) -> String {
    match expr {
        Expr::Int(i) => i.to_string(),
        Expr::Bool(true) => "TRUE".to_string(),
        Expr::Bool(false) => "FALSE".to_string(),
        Expr::Var(v) => v.clone(),
        Expr::Prime(v) => format!("{v}'"),
        Expr::BinOp { left, op, right } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Sub => "-",
                BinOp::Mul | BinOp::Shl => "*", // Shl: 2^n multiplication approximation
                BinOp::Div | BinOp::Shr => "\\div", // Shr: 2^n division approximation
                BinOp::Mod => "%",
                BinOp::BitAnd => "&&", // TLA+ doesn't have bitwise, use logical
                BinOp::BitOr => "||",
                BinOp::BitXor => "^^", // Placeholder
            };
            format!(
                "({} {} {})",
                expr_to_tla2(left),
                op_str,
                expr_to_tla2(right)
            )
        }
        Expr::UnaryOp { op, arg } => {
            let op_str = match op {
                UnaryOp::Neg => "-",
                UnaryOp::Not | UnaryOp::BitNot => "~",
            };
            format!("{}({})", op_str, expr_to_tla2(arg))
        }
        Expr::If { cond, then_, else_ } => {
            format!(
                "IF {} THEN {} ELSE {}",
                predicate_to_tla2(cond),
                expr_to_tla2(then_),
                expr_to_tla2(else_)
            )
        }
        Expr::Tuple(elems) => {
            let parts: Vec<String> = elems.iter().map(expr_to_tla2).collect();
            format!("<<{}>>", parts.join(", "))
        }
        Expr::Project { tuple, index } => {
            format!("{}[{}]", expr_to_tla2(tuple), index + 1) // TLA+ is 1-indexed
        }
        Expr::SetLit(elems) => {
            let parts: Vec<String> = elems.iter().map(expr_to_tla2).collect();
            format!("{{{}}}", parts.join(", "))
        }
        Expr::SetComp {
            var,
            domain,
            filter,
        } => {
            format!(
                "{{ {} \\in {}: {} }}",
                var,
                expr_to_tla2(domain),
                predicate_to_tla2(filter)
            )
        }
        Expr::Apply { func, args } => {
            if args.is_empty() {
                func.clone()
            } else {
                let arg_strs: Vec<String> = args.iter().map(expr_to_tla2).collect();
                format!("{}({})", func, arg_strs.join(", "))
            }
        }
    }
}

/// Convert a transition to TLA+ action definition
fn transition_to_tla2(trans: &Transition) -> String {
    let mut action = String::new();

    // Action name and comment
    if trans.is_yield {
        action.push_str("\\* Yield transition (suspension point)\n");
    } else if trans.is_poll {
        action.push_str("\\* Poll/resume transition\n");
    }

    let _ = writeln!(action, "{} ==", trans.name);

    // Guard (enabling condition)
    let _ = writeln!(action, "    /\\ {}", predicate_to_tla2(&trans.guard));

    // State change for _pc
    if let (Some(from), Some(to)) = (&trans.from, &trans.to) {
        if from.0 != to.0 {
            let _ = writeln!(action, "    /\\ _pc' = {}", to.0);
        }
    }

    // Assignments (primed variables)
    for assign in &trans.assignments {
        if assign.variable == "_pc" {
            // Already handled above
            continue;
        }
        let _ = writeln!(
            action,
            "    /\\ {}' = {}",
            assign.variable,
            expr_to_tla2(&assign.value)
        );
    }

    // UNCHANGED for variables not modified
    // Note: In a full implementation, we would track all model variables
    // and add UNCHANGED for those not in assignments.
    // For now, we add a placeholder comment.
    let _assigned_vars: std::collections::HashSet<&str> = trans
        .assignments
        .iter()
        .map(|a| a.variable.as_str())
        .collect();

    // Frame condition: unchanged variables
    action.push_str("    /\\ UNCHANGED <<>>  \\* Add unchanged variables here\n");

    action
}

/// Generate a minimal TLA+ config file for TLC
#[must_use]
pub fn generate_tla2_config(model: &TLA2Model) -> String {
    let mut cfg = String::new();

    cfg.push_str("\\* TLC Configuration for ");
    cfg.push_str(&model.name);
    cfg.push_str("\n\n");

    // SPECIFICATION
    cfg.push_str("SPECIFICATION Spec\n\n");

    // CONSTANTS
    let max_state = model
        .terminal_states
        .iter()
        .map(|s| s.0)
        .max()
        .unwrap_or(10);
    let _ = writeln!(cfg, "CONSTANT MaxState = {max_state}\n");

    // INVARIANTS
    cfg.push_str("INVARIANT TypeInvariant\n");
    cfg.push_str("INVARIANT NoDeadlock\n\n");

    // PROPERTIES (if termination is expected)
    if !model.terminal_states.is_empty() {
        cfg.push_str("\\* PROPERTY Termination  \\* Uncomment to check liveness\n");
    }

    cfg
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::{ActionId, Assignment, StateId, Variable};

    fn simple_model() -> TLA2Model {
        let mut model = TLA2Model::new("simple_test");

        model.variables.push(Variable {
            name: "_pc".to_string(),
            ty: VarType::Int {
                bits: 32,
                signed: false,
            },
            invariant: None,
            initial_value: Some(Expr::Int(0)),
        });

        model.variables.push(Variable {
            name: "_state".to_string(),
            ty: VarType::Int {
                bits: 32,
                signed: false,
            },
            invariant: None,
            initial_value: Some(Expr::Int(0)),
        });

        model.init = Predicate::And(vec![
            Predicate::Compare {
                left: Box::new(Expr::Var("_pc".to_string())),
                op: CompareOp::Eq,
                right: Box::new(Expr::Int(0)),
            },
            Predicate::Compare {
                left: Box::new(Expr::Var("_state".to_string())),
                op: CompareOp::Eq,
                right: Box::new(Expr::Int(0)),
            },
        ]);

        model.transitions.push(Transition {
            action_id: ActionId(0),
            name: "step_0_to_1".to_string(),
            from: Some(StateId(0)),
            to: Some(StateId(1)),
            guard: Predicate::Compare {
                left: Box::new(Expr::Var("_pc".to_string())),
                op: CompareOp::Eq,
                right: Box::new(Expr::Int(0)),
            },
            assignments: vec![Assignment {
                variable: "_pc".to_string(),
                value: Expr::Int(1),
            }],
            is_yield: false,
            is_poll: false,
        });

        model.terminal_states.push(StateId(1));

        model
    }

    #[test]
    fn test_generate_spec() {
        let model = simple_model();
        let spec = generate_tla2_spec(&model);

        assert!(spec.contains("---- MODULE simple_test ----"));
        assert!(spec.contains("VARIABLES _pc, _state"));
        assert!(spec.contains("Init =="));
        assert!(spec.contains("Next =="));
        assert!(spec.contains("Spec =="));
    }

    #[test]
    fn test_predicate_to_tla2() {
        let pred = Predicate::Compare {
            left: Box::new(Expr::Var("x".to_string())),
            op: CompareOp::Eq,
            right: Box::new(Expr::Int(42)),
        };
        assert_eq!(predicate_to_tla2(&pred), "x = 42");

        let and_pred = Predicate::And(vec![Predicate::Bool(true), Predicate::Bool(false)]);
        assert_eq!(predicate_to_tla2(&and_pred), "(TRUE /\\ FALSE)");
    }

    #[test]
    fn test_expr_to_tla2() {
        assert_eq!(expr_to_tla2(&Expr::Int(42)), "42");
        assert_eq!(expr_to_tla2(&Expr::Bool(true)), "TRUE");
        assert_eq!(expr_to_tla2(&Expr::Var("x".to_string())), "x");

        let add = Expr::BinOp {
            left: Box::new(Expr::Var("x".to_string())),
            op: BinOp::Add,
            right: Box::new(Expr::Int(1)),
        };
        assert_eq!(expr_to_tla2(&add), "(x + 1)");
    }

    #[test]
    fn test_generate_config() {
        let model = simple_model();
        let cfg = generate_tla2_config(&model);

        assert!(cfg.contains("SPECIFICATION Spec"));
        assert!(cfg.contains("INVARIANT TypeInvariant"));
    }

    #[test]
    fn test_sanitize_module_name() {
        assert_eq!(sanitize_module_name("simple_test"), "simple_test");
        assert_eq!(sanitize_module_name("test::module"), "test__module");
        assert_eq!(sanitize_module_name("fn-name"), "fn_name");
    }
}
