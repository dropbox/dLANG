//! Tactic execution for verification conditions
//!
//! This module implements the actual execution of proof tactics, transforming
//! verification conditions into subgoals that can be discharged by SMT solvers
//! or other proof backends.
//!
//! Tactics allow users to guide the verification process when automatic proof
//! search fails, by providing hints about proof structure (e.g., induction,
//! case splitting).

use crate::{
    specs::{
        CaseSplitCondition, InductionTarget, TacticAnnotation, TacticHint, TacticKind,
        TacticRegistry, TacticTransform,
    },
    Expr, Predicate, SourceSpan,
};
use serde::{Deserialize, Serialize};

/// Result of applying a tactic to a verification condition
#[derive(Debug, Clone)]
pub struct TacticResult {
    /// The subgoals that must all be proven to complete the tactic
    pub subgoals: Vec<SubGoal>,
    /// Description of the tactic application
    pub description: String,
    /// Whether all subgoals must succeed (And) or just one (Or)
    pub mode: TacticMode,
}

/// Mode for combining subgoal results
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum TacticMode {
    /// All subgoals must be proven (conjunction)
    #[default]
    All,
    /// At least one subgoal must be proven (disjunction, for case analysis)
    Any,
}

/// A subgoal generated by a tactic
#[derive(Debug, Clone)]
pub struct SubGoal {
    /// Name of this subgoal for reporting
    pub name: String,
    /// Additional assumptions available in this subgoal
    pub assumptions: Vec<Predicate>,
    /// The goal predicate to prove
    pub goal: Predicate,
    /// Source span for error reporting
    pub span: SourceSpan,
    /// Optional hint for the backend
    pub hint: Option<String>,
}

impl SubGoal {
    /// Create a new subgoal
    pub fn new(name: impl Into<String>, goal: Predicate, span: SourceSpan) -> Self {
        Self {
            name: name.into(),
            assumptions: Vec::new(),
            goal,
            span,
            hint: None,
        }
    }

    /// Add an assumption to this subgoal
    #[must_use]
    pub fn with_assumption(mut self, assumption: Predicate) -> Self {
        self.assumptions.push(assumption);
        self
    }

    /// Add multiple assumptions
    #[must_use]
    pub fn with_assumptions(mut self, assumptions: impl IntoIterator<Item = Predicate>) -> Self {
        self.assumptions.extend(assumptions);
        self
    }

    /// Add a backend hint
    #[must_use]
    pub fn with_hint(mut self, hint: impl Into<String>) -> Self {
        self.hint = Some(hint.into());
        self
    }

    /// Convert assumptions and goal to a single implication predicate
    #[must_use]
    pub fn to_predicate(&self) -> Predicate {
        if self.assumptions.is_empty() {
            self.goal.clone()
        } else {
            let antecedent = Predicate::and(self.assumptions.clone());
            antecedent.implies(self.goal.clone())
        }
    }
}

impl TacticResult {
    /// Create a result with multiple subgoals that must all be proven
    pub fn all(subgoals: Vec<SubGoal>, description: impl Into<String>) -> Self {
        Self {
            subgoals,
            description: description.into(),
            mode: TacticMode::All,
        }
    }

    /// Create a result with subgoals where any one suffices
    pub fn any(subgoals: Vec<SubGoal>, description: impl Into<String>) -> Self {
        Self {
            subgoals,
            description: description.into(),
            mode: TacticMode::Any,
        }
    }

    /// Check if the result has no subgoals (trivially discharged)
    #[must_use]
    pub const fn is_trivial(&self) -> bool {
        self.subgoals.is_empty()
    }

    /// Get the number of subgoals
    #[must_use]
    pub const fn num_subgoals(&self) -> usize {
        self.subgoals.len()
    }
}

/// Executor for proof tactics
#[derive(Debug, Clone, Default)]
pub struct TacticExecutor {
    /// Registry of custom tactics
    pub registry: TacticRegistry,
}

impl TacticExecutor {
    /// Create a new tactic executor with empty registry
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Create an executor with a custom registry
    #[must_use]
    pub const fn with_registry(registry: TacticRegistry) -> Self {
        Self { registry }
    }

    /// Apply a tactic annotation to transform a goal predicate into subgoals
    pub fn apply_tactic(
        &self,
        annotation: &TacticAnnotation,
        goal: &Predicate,
    ) -> Result<TacticResult, TacticError> {
        match &annotation.kind {
            TacticKind::Induction(target) => {
                self.apply_induction(target, goal, &annotation.hints, annotation.span.clone())
            }
            TacticKind::CaseSplit(condition) => {
                self.apply_case_split(condition, goal, annotation.span.clone())
            }
            TacticKind::Custom(name) => self.apply_custom(name, goal, annotation.span.clone()),
        }
    }

    /// Apply induction tactic
    ///
    /// For integer induction on variable `n`, generates:
    /// - Base case: goal[n := 0]
    /// - Inductive step: forall k >= 0. goal[n := k] => goal[n := k+1]
    pub fn apply_induction(
        &self,
        target: &InductionTarget,
        goal: &Predicate,
        hints: &[TacticHint],
        span: SourceSpan,
    ) -> Result<TacticResult, TacticError> {
        // Extract configuration from hints
        let base_value = hints
            .iter()
            .find_map(|h| match h {
                TacticHint::BaseCase(v) => Some(v.clone()),
                _ => None,
            })
            .unwrap_or_else(|| "0".to_string());

        let step_size = hints
            .iter()
            .find_map(|h| match h {
                TacticHint::StepSize(s) => Some(*s),
                _ => None,
            })
            .unwrap_or(1);

        match target {
            InductionTarget::Variable(var) => {
                let subgoals = Self::generate_integer_induction_subgoals(
                    var,
                    goal,
                    &base_value,
                    step_size,
                    span,
                );
                Ok(TacticResult::all(subgoals, format!("induction on {var}")))
            }
            InductionTarget::Parameter(idx) => {
                // For parameter induction, we need to determine the parameter name
                // This is typically done by the caller who has context
                let var = format!("_param_{idx}");
                let subgoals = Self::generate_integer_induction_subgoals(
                    &var,
                    goal,
                    &base_value,
                    step_size,
                    span,
                );
                Ok(TacticResult::all(
                    subgoals,
                    format!("induction on parameter {idx}"),
                ))
            }
            InductionTarget::Tuple(vars) => {
                // Simultaneous induction on multiple variables
                // This is more complex - we generate base case for all vars at base
                // and step case that can step any one variable
                let subgoals = Self::generate_tuple_induction_subgoals(
                    vars,
                    goal,
                    &base_value,
                    step_size,
                    span,
                );
                Ok(TacticResult::all(
                    subgoals,
                    format!("simultaneous induction on ({})", vars.join(", ")),
                ))
            }
            InductionTarget::Structural(ty) => {
                // Structural induction requires knowing the type's structure
                // For now, return an error asking for more information
                Err(TacticError::UnsupportedTarget {
                    target: format!("structural induction on {ty}"),
                    reason: "structural induction requires type information".into(),
                })
            }
        }
    }

    /// Generate subgoals for integer induction
    fn generate_integer_induction_subgoals(
        var: &str,
        goal: &Predicate,
        base_value: &str,
        step_size: i64,
        span: SourceSpan,
    ) -> Vec<SubGoal> {
        // Base case: P(base_value)
        let base_case = SubGoal::new(
            format!("base case: {var} = {base_value}"),
            substitute_var(goal, var, base_value),
            span.clone(),
        )
        .with_hint("base case - typically solvable by simplification");

        // Inductive hypothesis: assume P(k) for k >= base_value
        let k_var = format!("{var}_k");
        let ih_assumption = substitute_var(goal, var, &k_var);

        // Inductive step: P(k) => P(k + step_size)
        let step_expr = if step_size == 1 {
            format!("(+ {k_var} 1)")
        } else if step_size == -1 {
            format!("(- {k_var} 1)")
        } else {
            format!("(+ {k_var} {step_size})")
        };

        let step_goal = substitute_var(goal, var, &step_expr);

        // Bound assumption: k >= base_value
        let bound_assumption = Predicate::Expr(Expr::Raw(format!("(>= {k_var} {base_value})")));

        let inductive_step = SubGoal::new(
            format!("inductive step: {var} -> {var} + {step_size}"),
            step_goal,
            span,
        )
        .with_assumption(bound_assumption)
        .with_assumption(ih_assumption)
        .with_hint("inductive step - use inductive hypothesis");

        vec![base_case, inductive_step]
    }

    /// Generate subgoals for simultaneous induction on multiple variables
    fn generate_tuple_induction_subgoals(
        vars: &[String],
        goal: &Predicate,
        base_value: &str,
        step_size: i64,
        span: SourceSpan,
    ) -> Vec<SubGoal> {
        let mut subgoals = Vec::new();

        // Base case: all variables at base value
        let mut base_goal = goal.clone();
        for var in vars {
            base_goal = substitute_var(&base_goal, var, base_value);
        }
        subgoals.push(
            SubGoal::new(
                format!("base case: all vars = {base_value}"),
                base_goal,
                span.clone(),
            )
            .with_hint("base case for simultaneous induction"),
        );

        // Step cases: for each variable, step it while keeping others with IH
        for (i, step_var) in vars.iter().enumerate() {
            let k_vars: Vec<_> = vars.iter().map(|v| format!("{v}_k")).collect();

            // IH: assume goal holds for (k1, k2, ..., kn)
            let mut ih = goal.clone();
            for (v, kv) in vars.iter().zip(&k_vars) {
                ih = substitute_var(&ih, v, kv);
            }

            // Step goal: goal holds for (k1, ..., ki + step, ..., kn)
            let mut step_goal = goal.clone();
            for (j, (v, kv)) in vars.iter().zip(&k_vars).enumerate() {
                if i == j {
                    let step_expr = format!("(+ {kv} {step_size})");
                    step_goal = substitute_var(&step_goal, v, &step_expr);
                } else {
                    step_goal = substitute_var(&step_goal, v, kv);
                }
            }

            // Bound assumptions
            let mut step_subgoal = SubGoal::new(
                format!("step {}: increment {}", i + 1, step_var),
                step_goal,
                span.clone(),
            )
            .with_assumption(ih);

            for kv in &k_vars {
                step_subgoal = step_subgoal.with_assumption(Predicate::Expr(Expr::Raw(format!(
                    "(>= {kv} {base_value})"
                ))));
            }

            subgoals.push(step_subgoal.with_hint(format!("step case for {step_var} - use IH")));
        }

        subgoals
    }

    /// Apply case split tactic
    ///
    /// Splits the proof into multiple cases based on the condition.
    /// For expression split on condition C:
    /// - Case 1: C => goal
    /// - Case 2: !C => goal
    pub fn apply_case_split(
        &self,
        condition: &CaseSplitCondition,
        goal: &Predicate,
        span: SourceSpan,
    ) -> Result<TacticResult, TacticError> {
        let cases = condition.get_cases();

        let subgoals: Vec<SubGoal> = cases
            .into_iter()
            .map(|(name, smt_condition)| {
                let assumption = Predicate::Expr(Expr::Raw(smt_condition));
                SubGoal::new(name, goal.clone(), span.clone())
                    .with_assumption(assumption)
                    .with_hint("case assumption added - may simplify goal")
            })
            .collect();

        Ok(TacticResult::all(
            subgoals,
            format!("case split on {}", condition.description()),
        ))
    }

    /// Apply a custom tactic from the registry
    pub fn apply_custom(
        &self,
        name: &str,
        goal: &Predicate,
        span: SourceSpan,
    ) -> Result<TacticResult, TacticError> {
        let tactic = self
            .registry
            .get(name)
            .ok_or_else(|| TacticError::UnknownTactic {
                name: name.to_string(),
                available: self
                    .registry
                    .names()
                    .map(std::string::ToString::to_string)
                    .collect(),
            })?;

        self.apply_transform(&tactic.transform, goal, span, &tactic.description)
    }

    /// Apply a tactic transform to a goal
    #[allow(clippy::only_used_in_recursion)] // &self needed for recursive Sequence handling
    pub fn apply_transform(
        &self,
        transform: &TacticTransform,
        goal: &Predicate,
        span: SourceSpan,
        description: &str,
    ) -> Result<TacticResult, TacticError> {
        match transform {
            TacticTransform::Split { subgoals: names } => {
                // Split creates named subgoals with the same goal
                let subgoals = names
                    .iter()
                    .map(|name| SubGoal::new(name, goal.clone(), span.clone()))
                    .collect();
                Ok(TacticResult::all(subgoals, description))
            }
            TacticTransform::Assume { assumptions } => {
                // Add assumptions to the goal
                let assumption_preds: Vec<Predicate> = assumptions
                    .iter()
                    .map(|a| Predicate::Expr(Expr::Raw(a.clone())))
                    .collect();

                let subgoal = SubGoal::new(
                    format!("{description} (with assumptions)"),
                    goal.clone(),
                    span,
                )
                .with_assumptions(assumption_preds);

                Ok(TacticResult::all(vec![subgoal], description))
            }
            TacticTransform::Unfold { name: def_name } => {
                // Unfold a definition - this would require definition lookup
                // For now, we return the goal unchanged with a hint
                let subgoal = SubGoal::new(format!("unfold {def_name}"), goal.clone(), span)
                    .with_hint(format!("unfold definition of {def_name}"));

                Ok(TacticResult::all(vec![subgoal], description))
            }
            TacticTransform::Simplify => {
                // Simplify the goal - actual simplification would require
                // expression normalization which is backend-specific
                let subgoal = SubGoal::new(
                    "simplified goal",
                    goal.clone(), // In a real implementation, simplify here
                    span,
                )
                .with_hint("apply simplification rules");

                Ok(TacticResult::all(vec![subgoal], description))
            }
            TacticTransform::Sequence(transforms) => {
                // Apply transforms in sequence
                // Each transform refines the previous result
                let current_goal = goal.clone();
                let mut all_subgoals = Vec::new();

                for (i, t) in transforms.iter().enumerate() {
                    let result = self.apply_transform(
                        t,
                        &current_goal,
                        span.clone(),
                        &format!("step {} of {}", i + 1, description),
                    )?;

                    // For sequences, we chain the subgoals
                    // In a full implementation, each step would refine the goal
                    all_subgoals.extend(result.subgoals);
                }

                Ok(TacticResult::all(all_subgoals, description))
            }
        }
    }
}

/// Substitute a variable in a predicate with a new expression
///
/// This is a simple string-based substitution for SMT-LIB expressions.
/// For a more robust implementation, this would work on the AST.
fn substitute_var(pred: &Predicate, var: &str, replacement: &str) -> Predicate {
    match pred {
        Predicate::Bool(b) => Predicate::Bool(*b),
        Predicate::Expr(e) => {
            let new_expr = substitute_in_expr(e, var, replacement);
            Predicate::Expr(new_expr)
        }
        Predicate::Not(inner) => Predicate::Not(Box::new(substitute_var(inner, var, replacement))),
        Predicate::And(preds) => Predicate::And(
            preds
                .iter()
                .map(|p| substitute_var(p, var, replacement))
                .collect(),
        ),
        Predicate::Or(preds) => Predicate::Or(
            preds
                .iter()
                .map(|p| substitute_var(p, var, replacement))
                .collect(),
        ),
        Predicate::Implies(lhs, rhs) => Predicate::Implies(
            Box::new(substitute_var(lhs, var, replacement)),
            Box::new(substitute_var(rhs, var, replacement)),
        ),
        Predicate::Iff(lhs, rhs) => Predicate::Iff(
            Box::new(substitute_var(lhs, var, replacement)),
            Box::new(substitute_var(rhs, var, replacement)),
        ),
        Predicate::Forall {
            vars,
            triggers,
            body,
        } => {
            // Don't substitute if var is bound
            if vars.iter().any(|(v, _)| v == var) {
                pred.clone()
            } else {
                Predicate::Forall {
                    vars: vars.clone(),
                    triggers: triggers
                        .iter()
                        .map(|ts| {
                            ts.iter()
                                .map(|e| substitute_in_expr(e, var, replacement))
                                .collect()
                        })
                        .collect(),
                    body: Box::new(substitute_var(body, var, replacement)),
                }
            }
        }
        Predicate::Exists { vars, body } => {
            if vars.iter().any(|(v, _)| v == var) {
                pred.clone()
            } else {
                Predicate::Exists {
                    vars: vars.clone(),
                    body: Box::new(substitute_var(body, var, replacement)),
                }
            }
        }
        Predicate::Let { bindings, body } => {
            // Don't substitute in bindings if var is being bound
            let bound_here = bindings.iter().any(|(v, _)| v == var);

            let new_bindings = bindings
                .iter()
                .map(|(v, e)| (v.clone(), substitute_in_expr(e, var, replacement)))
                .collect();

            let new_body = if bound_here {
                body.clone()
            } else {
                Box::new(substitute_var(body, var, replacement))
            };

            Predicate::Let {
                bindings: new_bindings,
                body: new_body,
            }
        }
    }
}

/// Substitute a variable in an expression
fn substitute_in_expr(expr: &Expr, var: &str, replacement: &str) -> Expr {
    match expr {
        Expr::Var(v) if v == var => Expr::Raw(replacement.to_string()),
        Expr::Raw(s) => {
            // Simple word-boundary substitution for SMT-LIB
            let pattern = format!(r"\b{}\b", regex::escape(var));
            if let Ok(re) = regex::Regex::new(&pattern) {
                Expr::Raw(re.replace_all(s, replacement).to_string())
            } else {
                Expr::Raw(s.replace(var, replacement))
            }
        }
        // For other expression types, we'd need to recurse
        _ => expr.clone(),
    }
}

/// Errors that can occur during tactic execution
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TacticError {
    /// The tactic target is not supported
    UnsupportedTarget { target: String, reason: String },
    /// Unknown custom tactic
    UnknownTactic {
        name: String,
        available: Vec<String>,
    },
    /// Tactic application failed
    ApplicationFailed { tactic: String, reason: String },
}

impl std::fmt::Display for TacticError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnsupportedTarget { target, reason } => {
                write!(f, "unsupported tactic target '{target}': {reason}")
            }
            Self::UnknownTactic { name, available } => {
                write!(f, "unknown tactic '{name}', available: {available:?}")
            }
            Self::ApplicationFailed { tactic, reason } => {
                write!(f, "tactic '{tactic}' failed: {reason}")
            }
        }
    }
}

impl std::error::Error for TacticError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{CustomTactic, VcType};

    #[test]
    fn test_subgoal_creation() {
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();
        let sg = SubGoal::new("test", goal.clone(), span);

        assert_eq!(sg.name, "test");
        assert!(sg.assumptions.is_empty());
        assert!(sg.hint.is_none());
    }

    #[test]
    fn test_subgoal_with_assumptions() {
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();
        let assumption = Predicate::Expr(Expr::Raw("(> x 0)".to_string()));

        let sg = SubGoal::new("test", goal, span).with_assumption(assumption);

        assert_eq!(sg.assumptions.len(), 1);
    }

    #[test]
    fn test_subgoal_to_predicate_no_assumptions() {
        let goal = Predicate::Expr(Expr::Raw("(> x 0)".to_string()));
        let span = SourceSpan::default();
        let sg = SubGoal::new("test", goal.clone(), span);

        // Without assumptions, to_predicate returns the goal
        let pred = sg.to_predicate();
        assert!(matches!(pred, Predicate::Expr(_)));
    }

    #[test]
    fn test_subgoal_to_predicate_with_assumptions() {
        let goal = Predicate::Expr(Expr::Raw("(> x 0)".to_string()));
        let assumption = Predicate::Expr(Expr::Raw("(>= x 0)".to_string()));
        let span = SourceSpan::default();

        let sg = SubGoal::new("test", goal, span).with_assumption(assumption);

        let pred = sg.to_predicate();
        // Should be an implication: assumption => goal
        assert!(matches!(pred, Predicate::Implies(_, _)));
    }

    #[test]
    fn test_tactic_result_all() {
        let subgoals = vec![
            SubGoal::new("g1", Predicate::Bool(true), SourceSpan::default()),
            SubGoal::new("g2", Predicate::Bool(true), SourceSpan::default()),
        ];

        let result = TacticResult::all(subgoals, "test tactic");

        assert_eq!(result.num_subgoals(), 2);
        assert_eq!(result.mode, TacticMode::All);
        assert!(!result.is_trivial());
    }

    #[test]
    fn test_tactic_result_trivial() {
        let result = TacticResult::all(vec![], "empty");
        assert!(result.is_trivial());
    }

    #[test]
    fn test_executor_induction_variable() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Expr(Expr::Raw("(>= (factorial n) 1)".to_string()));
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(TacticKind::induction("n"), span);

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        // Should have 2 subgoals: base case and inductive step
        assert_eq!(result.num_subgoals(), 2);
        assert!(result.description.contains("induction"));

        // First is base case
        assert!(result.subgoals[0].name.contains("base"));

        // Second is inductive step
        assert!(result.subgoals[1].name.contains("step"));
        // Inductive step should have assumptions
        assert!(!result.subgoals[1].assumptions.is_empty());
    }

    #[test]
    fn test_executor_induction_with_hints() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Expr(Expr::Raw("(>= n 1)".to_string()));
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(TacticKind::induction("n"), span)
            .with_hint(TacticHint::base_case("1"))
            .with_hint(TacticHint::step(2));

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        // Base case should use custom base value
        assert!(result.subgoals[0].name.contains('1'));
    }

    #[test]
    fn test_executor_case_split_expression() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Expr(Expr::Raw("(> result 0)".to_string()));
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::CaseSplit(CaseSplitCondition::expr("(> x 0)")),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        // Should have 2 subgoals: condition true and condition false
        assert_eq!(result.num_subgoals(), 2);

        // Each case should have an assumption
        for sg in &result.subgoals {
            assert_eq!(sg.assumptions.len(), 1);
        }
    }

    #[test]
    fn test_executor_case_split_sign() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation =
            TacticAnnotation::new(TacticKind::CaseSplit(CaseSplitCondition::sign("x")), span);

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        assert_eq!(result.num_subgoals(), 2);
        assert!(result.subgoals[0].name.contains(">= 0"));
        assert!(result.subgoals[1].name.contains("< 0"));
    }

    #[test]
    fn test_executor_case_split_option() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::CaseSplit(CaseSplitCondition::option("opt")),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        assert_eq!(result.num_subgoals(), 2);
        assert!(result.subgoals[0].name.contains("is_some"));
        assert!(result.subgoals[1].name.contains("is_none"));
    }

    #[test]
    fn test_executor_case_split_result() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::CaseSplit(CaseSplitCondition::result("res")),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        assert_eq!(result.num_subgoals(), 2);
        assert!(result.subgoals[0].name.contains("is_ok"));
        assert!(result.subgoals[1].name.contains("is_err"));
    }

    #[test]
    fn test_executor_custom_tactic() {
        let mut registry = TacticRegistry::new();
        registry.register(CustomTactic::new(
            "my_tactic",
            "A custom test tactic",
            TacticTransform::Simplify,
        ));

        let executor = TacticExecutor::with_registry(registry);
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(TacticKind::Custom("my_tactic".to_string()), span);

        let result = executor.apply_tactic(&annotation, &goal).unwrap();
        assert!(!result.is_trivial());
    }

    #[test]
    fn test_executor_unknown_custom_tactic() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(TacticKind::Custom("nonexistent".to_string()), span);

        let result = executor.apply_tactic(&annotation, &goal);
        assert!(result.is_err());

        match result.unwrap_err() {
            TacticError::UnknownTactic { name, .. } => {
                assert_eq!(name, "nonexistent");
            }
            _ => panic!("expected UnknownTactic error"),
        }
    }

    #[test]
    fn test_executor_transform_split() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let transform = TacticTransform::Split {
            subgoals: vec!["case1".to_string(), "case2".to_string()],
        };

        let result = executor
            .apply_transform(&transform, &goal, span, "test split")
            .unwrap();

        assert_eq!(result.num_subgoals(), 2);
        assert_eq!(result.subgoals[0].name, "case1");
        assert_eq!(result.subgoals[1].name, "case2");
    }

    #[test]
    fn test_executor_transform_assume() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let transform = TacticTransform::Assume {
            assumptions: vec!["(> x 0)".to_string(), "(< x 10)".to_string()],
        };

        let result = executor
            .apply_transform(&transform, &goal, span, "test assume")
            .unwrap();

        assert_eq!(result.num_subgoals(), 1);
        assert_eq!(result.subgoals[0].assumptions.len(), 2);
    }

    #[test]
    fn test_executor_transform_sequence() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let transform =
            TacticTransform::Sequence(vec![TacticTransform::Simplify, TacticTransform::Simplify]);

        let result = executor
            .apply_transform(&transform, &goal, span, "test sequence")
            .unwrap();

        // Each step creates a subgoal
        assert_eq!(result.num_subgoals(), 2);
    }

    #[test]
    fn test_substitute_var_simple() {
        let pred = Predicate::Expr(Expr::Raw("(> n 0)".to_string()));
        let result = substitute_var(&pred, "n", "0");

        if let Predicate::Expr(Expr::Raw(s)) = result {
            assert!(s.contains('0'));
        } else {
            panic!("expected Expr");
        }
    }

    #[test]
    fn test_substitute_var_not() {
        let inner = Predicate::Expr(Expr::Raw("(> x 0)".to_string()));
        let pred = Predicate::Not(Box::new(inner));

        let result = substitute_var(&pred, "x", "y");

        if let Predicate::Not(inner) = result {
            if let Predicate::Expr(Expr::Raw(s)) = *inner {
                assert!(s.contains('y'));
            }
        }
    }

    #[test]
    fn test_substitute_var_and() {
        let p1 = Predicate::Expr(Expr::Raw("(> x 0)".to_string()));
        let p2 = Predicate::Expr(Expr::Raw("(< x 10)".to_string()));
        let pred = Predicate::And(vec![p1, p2]);

        let result = substitute_var(&pred, "x", "n");

        if let Predicate::And(preds) = result {
            assert_eq!(preds.len(), 2);
        }
    }

    #[test]
    fn test_substitute_var_forall_bound() {
        // Substitution should not happen for bound variables
        let pred = Predicate::Forall {
            vars: vec![(
                "x".to_string(),
                VcType::Int {
                    signed: true,
                    bits: 32,
                },
            )],
            triggers: vec![],
            body: Box::new(Predicate::Expr(Expr::Raw("(> x 0)".to_string()))),
        };

        // Try to substitute x - should be blocked since x is bound
        let result = substitute_var(&pred, "x", "y");

        // Should be unchanged
        if let Predicate::Forall { body, .. } = result {
            if let Predicate::Expr(Expr::Raw(s)) = *body {
                assert!(s.contains('x')); // x should NOT be replaced
            }
        }
    }

    #[test]
    fn test_substitute_var_forall_free() {
        // Substitution should happen for free variables
        let pred = Predicate::Forall {
            vars: vec![(
                "x".to_string(),
                VcType::Int {
                    signed: true,
                    bits: 32,
                },
            )],
            triggers: vec![],
            body: Box::new(Predicate::Expr(Expr::Raw("(> y 0)".to_string()))),
        };

        // Substitute y - should work since y is free
        let result = substitute_var(&pred, "y", "z");

        if let Predicate::Forall { body, .. } = result {
            if let Predicate::Expr(Expr::Raw(s)) = *body {
                assert!(s.contains('z')); // y should be replaced
            }
        }
    }

    #[test]
    fn test_tuple_induction() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Expr(Expr::Raw("(>= (+ x y) 0)".to_string()));
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::Induction(InductionTarget::Tuple(vec![
                "x".to_string(),
                "y".to_string(),
            ])),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        // Base case + one step case per variable = 3 subgoals
        assert_eq!(result.num_subgoals(), 3);
        assert!(result.description.contains("simultaneous"));
    }

    #[test]
    fn test_structural_induction_unsupported() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::Induction(InductionTarget::Structural("List".to_string())),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal);

        assert!(result.is_err());
        match result.unwrap_err() {
            TacticError::UnsupportedTarget { target, .. } => {
                assert!(target.contains("List"));
            }
            _ => panic!("expected UnsupportedTarget error"),
        }
    }

    #[test]
    fn test_tactic_error_display() {
        let err = TacticError::UnknownTactic {
            name: "foo".to_string(),
            available: vec!["bar".to_string(), "baz".to_string()],
        };

        let s = err.to_string();
        assert!(s.contains("foo"));
        assert!(s.contains("bar"));
    }

    #[test]
    fn test_induction_parameter() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Expr(Expr::Raw("(>= _param_0 0)".to_string()));
        let span = SourceSpan::default();

        let annotation =
            TacticAnnotation::new(TacticKind::Induction(InductionTarget::Parameter(0)), span);

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        assert_eq!(result.num_subgoals(), 2);
        assert!(result.description.contains("parameter 0"));
    }

    #[test]
    fn test_case_split_enum() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let annotation = TacticAnnotation::new(
            TacticKind::CaseSplit(CaseSplitCondition::enum_split(
                "color",
                vec!["Red".to_string(), "Green".to_string(), "Blue".to_string()],
            )),
            span,
        );

        let result = executor.apply_tactic(&annotation, &goal).unwrap();

        // One subgoal per variant
        assert_eq!(result.num_subgoals(), 3);
    }

    #[test]
    fn test_transform_unfold() {
        let executor = TacticExecutor::new();
        let goal = Predicate::Bool(true);
        let span = SourceSpan::default();

        let transform = TacticTransform::Unfold {
            name: "my_definition".to_string(),
        };

        let result = executor
            .apply_transform(&transform, &goal, span, "unfold")
            .unwrap();

        assert_eq!(result.num_subgoals(), 1);
        assert!(result.subgoals[0]
            .hint
            .as_ref()
            .unwrap()
            .contains("my_definition"));
    }
}
