# tRust Verification Error Explanations
# Format: CODE|SHORT|LONG (| separated, LONG can have \n for newlines)

E0900|verification condition not provable|This error indicates that the SMT solver could not prove a verification condition. This typically means one of:\n\n1. **Postcondition not satisfied**: The function's `#[ensures(...)]` clause cannot be proven from the implementation.\n\n2. **Precondition violation**: A call site does not satisfy the callee's `#[requires(...)]` precondition.\n\n3. **Overflow possible**: An arithmetic operation may overflow without proper bounds checks.\n\n**Common fixes:**\n- Add missing preconditions with `#[requires(...)]`\n- Use checked arithmetic: `a.checked_add(b)`, `a.saturating_add(b)`\n- Add bounds checks before potentially overflowing operations\n- Ensure postconditions follow from your implementation logic\n\n**Example:**\n```rust\n// Error: postcondition cannot be proven\n#[ensures(result > 0)]\nfn abs(x: i32) -> i32 {\n    if x < 0 { -x } else { x }  // -x overflows for i32::MIN!\n}\n\n// Fixed: add precondition to exclude edge case\n#[requires(x > i32::MIN)]\n#[ensures(result >= 0)]\nfn abs(x: i32) -> i32 {\n    if x < 0 { -x } else { x }\n}\n```\n\nThe counterexample in the error message shows specific input values that violate the condition.

E0901|termination not proven|The verifier cannot prove that a recursive function or loop terminates.\n\n**For recursive functions**, add a `#[decreases(...)]` attribute specifying a measure that decreases on each recursive call:\n\n```rust\n#[decreases(n)]  // n decreases each call\nfn factorial(n: u64) -> u64 {\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n```\n\n**For loops**, add a `#[invariant(...)]` attribute and ensure the loop has a clear termination condition:\n\n```rust\nlet mut i = 0;\n#[invariant(i <= n)]\nwhile i < n {\n    // ...\n    i += 1;  // Progress toward termination\n}\n```\n\n**If termination is intentional** (e.g., server loops), mark with `#[may_diverge]`:\n\n```rust\n#[may_diverge]  // Explicitly non-terminating\nfn event_loop() {\n    loop { process_events(); }\n}\n```\n\nTermination proofs ensure programs don't hang - important for functions that should complete.

E0902|temporal property violated|A temporal logic specification cannot be proven. This applies to async code and distributed systems where properties involve time and ordering.\n\n**Common violations:**\n- `eventually(condition)` - condition may never become true\n- `always(invariant)` - invariant may be violated at some point\n- `until(p, q)` - p may not hold until q becomes true\n\n**Example:**\n```rust\n#[temporal(eventually(responded))]\nasync fn handle_request(req: Request) -> Response {\n    // Error: if validation fails, we might return early\n    // without setting 'responded' state\n    if !req.is_valid() {\n        return Response::bad_request();  // Missing responded!\n    }\n    process(req).await\n}\n```\n\n**Fixes:**\n- Ensure all code paths establish the required property\n- Add explicit state transitions for temporal tracking\n- Use `#[wire::recoverable]` for error paths that need recovery\n\nTemporal verification catches deadlocks, livelocks, and missing state transitions.

E0903|precondition not established|A function call does not satisfy the callee's precondition (`#[requires(...)]`).\n\n**The verifier checked:**\n1. The callee's precondition at the call site\n2. Whether current context implies the precondition\n3. Found the implication cannot be proven\n\n**Example:**\n```rust\n#[requires(x > 0)]\nfn positive_sqrt(x: f64) -> f64 { x.sqrt() }\n\nfn compute(val: f64) {\n    // Error: val > 0 not proven\n    let root = positive_sqrt(val);  // What if val <= 0?\n}\n```\n\n**Fixes:**\n- Add a precondition to the caller: `#[requires(val > 0)]`\n- Add a runtime check: `if val > 0 { positive_sqrt(val) } else { ... }`\n- Use the callee's contract to guide the fix\n\nModular verification: caller must prove callee's precondition.

E0904|invariant not preserved|A loop invariant is not maintained across iterations.\n\n**For an invariant to be valid:**\n1. **Establishment**: Invariant must hold before the loop\n2. **Preservation**: If invariant holds at start of iteration, it must hold at end\n3. **Usage**: Invariant + negated condition implies postcondition\n\n**Example:**\n```rust\nlet mut sum = 0;\nlet mut i = 0;\n#[invariant(sum == i * (i - 1) / 2)]  // Sum formula\nwhile i < n {\n    sum += i;  // After: sum == i*(i+1)/2, not i*(i-1)/2!\n    i += 1;\n}\n```\n\n**The fix** - adjust invariant to match actual loop semantics:\n```rust\n#[invariant(sum == i * (i - 1) / 2 && i <= n)]\n```\n\nInvariants are the key to unbounded loop verification.

E0905|refinement type mismatch|A value does not satisfy a refinement type's predicate.\n\n**Refinement types** add logical constraints to base types:\n```rust\ntype Positive = i32 where self > 0;\ntype NonEmpty<T> = Vec<T> where self.len() > 0;\n```\n\n**Example error:**\n```rust\nfn first(v: NonEmpty<i32>) -> i32 {\n    v[0]  // Safe: v.len() > 0 guaranteed\n}\n\nfn use_first(v: Vec<i32>) {\n    first(v)  // Error: Vec<i32> not proven NonEmpty\n}\n```\n\n**Fixes:**\n- Add runtime check: `if !v.is_empty() { first(v) } else { ... }`\n- Add precondition: `#[requires(!v.is_empty())]`\n- Use coercion: `let ne: NonEmpty<i32> = v.try_into()?;`\n\nRefinement types encode invariants in the type system.

E0906|arithmetic overflow possible|An arithmetic operation may overflow at runtime.\n\n**Rust's integer types have finite ranges:**\n- `u8`: 0 to 255\n- `i32`: -2,147,483,648 to 2,147,483,647\n- etc.\n\n**Example:**\n```rust\nfn double(x: u8) -> u8 {\n    x * 2  // Error: overflows when x > 127\n}\n```\n\n**Fixes:**\n\n1. **Add bounds**: `#[requires(x <= 127)]`\n\n2. **Use checked arithmetic**:\n   ```rust\n   x.checked_mul(2).unwrap_or(u8::MAX)\n   ```\n\n3. **Use saturating arithmetic**:\n   ```rust\n   x.saturating_mul(2)  // Clamps to MAX\n   ```\n\n4. **Use wrapping arithmetic** (explicit wrap):\n   ```rust\n   x.wrapping_mul(2)  // Wraps around\n   ```\n\n5. **Use wider type**:\n   ```rust\n   (x as u16) * 2  // Then check/truncate\n   ```\n\nThe counterexample shows an input that causes overflow.

E0907|division by zero possible|A division or modulo operation may have a zero divisor.\n\n**Example:**\n```rust\nfn average(sum: i32, count: i32) -> i32 {\n    sum / count  // Error: count could be 0\n}\n```\n\n**Fixes:**\n\n1. **Add precondition**:\n   ```rust\n   #[requires(count != 0)]\n   fn average(sum: i32, count: i32) -> i32\n   ```\n\n2. **Runtime check**:\n   ```rust\n   if count != 0 { sum / count } else { 0 }\n   ```\n\n3. **Use checked division**:\n   ```rust\n   sum.checked_div(count).unwrap_or(0)\n   ```\n\nThe verifier prevents undefined behavior from division by zero.

E0908|array index out of bounds|An array or slice access may be out of bounds.\n\n**Example:**\n```rust\nfn get_item(arr: &[i32], idx: usize) -> i32 {\n    arr[idx]  // Error: idx could be >= arr.len()\n}\n```\n\n**Fixes:**\n\n1. **Add precondition**:\n   ```rust\n   #[requires(idx < arr.len())]\n   fn get_item(arr: &[i32], idx: usize) -> i32\n   ```\n\n2. **Use safe access**:\n   ```rust\n   arr.get(idx).copied().unwrap_or(0)\n   ```\n\n3. **Bounds check**:\n   ```rust\n   if idx < arr.len() { arr[idx] } else { panic!(...) }\n   ```\n\nThe verifier ensures array accesses are always within bounds.

E0909|unsafe block requires proof|An unsafe block has verification conditions that must be proven.\n\n**Unsafe code** still needs to maintain safety invariants. tRust requires proof that unsafe operations don't cause undefined behavior.\n\n**Example:**\n```rust\nunsafe {\n    let ptr = get_ptr();\n    *ptr = 42;  // Error: ptr validity not proven\n}\n```\n\n**Requirements for unsafe verification:**\n- Pointer validity: `#[requires(ptr.is_valid())]`\n- Aliasing rules: no mutable aliasing\n- Lifetime correctness: referenced data outlives pointer\n\nUse `#[trusted]` to bypass verification for extern code, but this should be rare and documented.
