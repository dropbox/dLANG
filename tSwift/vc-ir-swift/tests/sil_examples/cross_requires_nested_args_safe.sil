sil_stage canonical

import Builtin
import Swift

// requiresPositive: requires x > 0
// This precondition will be verified as a CallPrecondition VC at call sites.
@_requires("x > 0")
func requiresPositive(_ x: Int) -> Int

// callWithSum: calls requiresPositive(a + b), precondition a + b > 0
// This tests MULTI-PARAMETER ARGUMENT EXPRESSION substitution in precondition obligations.
//
// Analysis:
// - Callee precondition: x > 0
// - Call: requiresPositive(a + b) where (a + b) is computed via SIL builtins
// - Substituted obligation: (a + b) > 0
// - Caller precondition: a + b > 0
// - With hypothesis a + b > 0, the call obligation is identical (QED)
@_requires("a + b > 0")
func callWithSum(_ a: Int, _ b: Int) -> Int

// requiresPositive implementation - identity function
sil hidden @$s19requires_nested_args16requiresPositiveyS2iF : $@convention(thin) (Int) -> Int {
bb0(%0 : $Int):
  debug_value %0, let, name "x", argno 1
  return %0
} // end sil function '$s19requires_nested_args16requiresPositiveyS2iF'

// callWithSum implementation - computes a + b, then calls requiresPositive(a + b)
sil hidden @$s19requires_nested_args11callWithSumyS2i_SitF : $@convention(thin) (Int, Int) -> Int {
bb0(%0 : $Int, %1 : $Int):
  debug_value %0, let, name "a", argno 1
  debug_value %1, let, name "b", argno 2
  // Compute a + b
  %4 = struct_extract %0, #Int._value      // a._value
  %5 = struct_extract %1, #Int._value      // b._value
  %6 = integer_literal $Builtin.Int1, 0
  %7 = builtin "sadd_with_overflow_Int64"(%4, %5, %6) : $(Builtin.Int64, Builtin.Int1)
  %8 = tuple_extract %7, 0                  // raw result = a + b
  %9 = struct $Int (%8)                     // wrap as Int
  // Call requiresPositive(a + b)
  %10 = function_ref @$s19requires_nested_args16requiresPositiveyS2iF : $@convention(thin) (Int) -> Int
  %11 = apply %10(%9) : $@convention(thin) (Int) -> Int
  return %11
} // end sil function '$s19requires_nested_args11callWithSumyS2i_SitF'
