sil_stage canonical

import Builtin
import Swift

// requiresPositive: requires x > 0
// This precondition will be verified as a CallPrecondition VC at call sites.
@_requires("x > 0")
func requiresPositive(_ x: Int) -> Int

// callWithAddOne: calls requiresPositive(a+1), precondition a >= 0
// This tests COMPLEX ARGUMENT EXPRESSION substitution in precondition obligations.
//
// Analysis:
// - Callee precondition: x > 0
// - Call: requiresPositive(a+1) where a+1 is computed via SIL builtin
// - Substituted obligation: (a+1) > 0, i.e., a + 1 > 0
// - Caller precondition: a >= 0
// - With hypothesis a >= 0 => a + 1 >= 1 > 0 (QED)
@_requires("a >= 0")
func callWithAddOne(_ a: Int) -> Int

// requiresPositive implementation - identity function
sil hidden @$s21requires_complex_args16requiresPositiveyS2iF : $@convention(thin) (Int) -> Int {
bb0(%0 : $Int):
  debug_value %0, let, name "x", argno 1
  return %0
} // end sil function '$s21requires_complex_args16requiresPositiveyS2iF'

// callWithAddOne implementation - computes a+1, then calls requiresPositive(a+1)
sil hidden @$s21requires_complex_args14callWithAddOneyS2iF : $@convention(thin) (Int) -> Int {
bb0(%0 : $Int):
  debug_value %0, let, name "a", argno 1
  // Compute a+1
  %2 = struct_extract %0, #Int._value      // a._value
  %3 = integer_literal $Builtin.Int64, 1
  %4 = integer_literal $Builtin.Int1, 0
  %5 = builtin "sadd_with_overflow_Int64"(%2, %3, %4) : $(Builtin.Int64, Builtin.Int1)
  %6 = tuple_extract %5, 0                  // raw result = a+1
  %7 = struct $Int (%6)                     // wrap as Int
  // Call requiresPositive(a+1)
  %8 = function_ref @$s21requires_complex_args16requiresPositiveyS2iF : $@convention(thin) (Int) -> Int
  %9 = apply %8(%7) : $@convention(thin) (Int) -> Int
  return %9
} // end sil function '$s21requires_complex_args14callWithAddOneyS2iF'
