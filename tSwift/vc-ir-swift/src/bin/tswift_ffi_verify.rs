//! tswift-ffi-verify CLI: Verify FFI compatibility between Swift and Rust sources.
//!
//! # Usage
//!
//! ```text
//! tswift-ffi-verify --swift <swift-files...> --rust <rust-files...> [OPTIONS]
//! tswift-ffi-verify --ffi-contract <contract.ffi.json> --swift <swift-files...> [OPTIONS]
//! tswift-ffi-verify --help
//! ```
//!
//! # Options
//!
//! - `--swift <files>` - Swift source files with @_ffi_* annotations
//! - `--generated <files>` - Swift source files generated by swift-bridge
//! - `--rust <files>` - Rust source files to parse for FFI exports
//! - `--ffi-contract <file>` - Load FFI specs from contract file instead of Rust source
//! - `--emit-contract <file>` - Generate contract file from Rust FFI exports
//! - `--emit-ffi-contract` - Alias for --emit-contract
//! - `--crate-name <name>` - Crate name for emitted contract (default: extracted from path)
//! - `--z4` - Use Z4 SMT solver for semantic implication proofs
//! - `--json` - Output results as JSON
//! - `--verbose` - Show detailed check results
//! - `-h, --help` - Show this help message

use std::env;
#[allow(unused_imports)] // Required for writeln! with String, clippy false positive
use std::fmt::Write as _;
use std::fs;
use std::process::ExitCode;

use vc_ir_swift::{
    FfiCompatibility, FfiContractFile, FfiLanguage, FfiSpecs, FfiVerifyOptions, FfiVerifyResult,
    ffi_specs_to_contract, parse_rust_ffi_declarations_from_source,
    parse_swift_bridge_generated_from_source, parse_swift_ffi_declarations_from_source,
    rust_decl_to_ffi_function_parsed, swift_decl_to_ffi_function_parsed,
    verify_ffi_compatibility_with_options,
};

/// Parsed command line arguments.
struct ParsedArgs {
    swift_files: Vec<String>,
    generated_files: Vec<String>,
    rust_files: Vec<String>,
    contract_file: Option<String>,
    emit_contract: Option<String>,
    crate_name: Option<String>,
    use_z4: bool,
    json_output: bool,
    verbose: bool,
}

/// Parse a single flag with value (--flag value or --flag=value).
fn parse_single_value_arg(args: &[String], i: &mut usize, flag: &str) -> Result<String, String> {
    fn split_equals_arg<'a>(arg: &'a str, flag: &str) -> Option<&'a str> {
        arg.strip_prefix(flag)
            .and_then(|rest| rest.strip_prefix('='))
    }

    if let Some(value) = split_equals_arg(&args[*i], flag) {
        if value.is_empty() {
            return Err(format!("error: {flag} requires a value"));
        }
        return Ok(value.to_string());
    }

    if args[*i] == flag {
        *i += 1;
        if *i < args.len() && !args[*i].starts_with("--") {
            return Ok(args[*i].clone());
        }
        return Err(format!("error: {flag} requires a value"));
    }

    Err(String::new()) // Not a match
}

/// Collect multiple file arguments until the next flag.
fn collect_file_args(args: &[String], i: &mut usize) -> Vec<String> {
    let mut files = Vec::new();
    *i += 1;
    while *i < args.len() && !args[*i].starts_with("--") {
        files.push(args[*i].clone());
        *i += 1;
    }
    files
}

/// Parse all command line arguments.
fn parse_arguments(args: &[String]) -> Result<ParsedArgs, String> {
    let mut parsed = ParsedArgs {
        swift_files: Vec::new(),
        generated_files: Vec::new(),
        rust_files: Vec::new(),
        contract_file: None,
        emit_contract: None,
        crate_name: None,
        use_z4: false,
        json_output: false,
        verbose: false,
    };

    let mut i = 1;
    'outer: while i < args.len() {
        // Try --ffi-contract
        match parse_single_value_arg(args, &mut i, "--ffi-contract") {
            Ok(value) => {
                parsed.contract_file = Some(value);
                i += 1;
                continue 'outer;
            }
            Err(e) if !e.is_empty() => return Err(e),
            _ => {}
        }

        // Try --emit-contract or --emit-ffi-contract
        for flag in &["--emit-contract", "--emit-ffi-contract"] {
            match parse_single_value_arg(args, &mut i, flag) {
                Ok(value) => {
                    parsed.emit_contract = Some(value);
                    i += 1;
                    continue 'outer;
                }
                Err(e) if !e.is_empty() => return Err(e),
                _ => {}
            }
        }

        // Try --crate-name
        match parse_single_value_arg(args, &mut i, "--crate-name") {
            Ok(value) => {
                parsed.crate_name = Some(value);
                i += 1;
                continue 'outer;
            }
            Err(e) if !e.is_empty() => return Err(e),
            _ => {}
        }

        match args[i].as_str() {
            "--swift" => parsed.swift_files = collect_file_args(args, &mut i),
            "--generated" => parsed.generated_files = collect_file_args(args, &mut i),
            "--rust" => parsed.rust_files = collect_file_args(args, &mut i),
            "--z4" => {
                parsed.use_z4 = true;
                i += 1;
            }
            "--json" => {
                parsed.json_output = true;
                i += 1;
            }
            "--verbose" => {
                parsed.verbose = true;
                i += 1;
            }
            arg => return Err(format!("error: unknown argument '{arg}'")),
        }
    }

    Ok(parsed)
}

/// Parse Swift files and add to specs. Returns errors.
fn parse_swift_files(
    specs: &mut FfiSpecs,
    swift_files: &[String],
    generated_files: &[String],
) -> Vec<String> {
    let mut errors = Vec::new();

    for path in swift_files {
        let Ok(content) = fs::read_to_string(path) else {
            errors.push(format!("error reading '{path}'"));
            continue;
        };
        for decl in parse_swift_ffi_declarations_from_source(&content, path) {
            match swift_decl_to_ffi_function_parsed(&decl, FfiLanguage::Swift) {
                Ok(ffi_fn) => specs.add(ffi_fn),
                Err(e) => errors.push(format!("{}:{}: error: {}", path, decl.source_line, e)),
            }
        }
    }

    for path in generated_files {
        let Ok(content) = fs::read_to_string(path) else {
            errors.push(format!("error reading '{path}'"));
            continue;
        };
        for decl in parse_swift_bridge_generated_from_source(&content, path) {
            match swift_decl_to_ffi_function_parsed(&decl, FfiLanguage::Swift) {
                Ok(ffi_fn) => specs.add(ffi_fn),
                Err(e) => errors.push(format!("{}:{}: error: {}", path, decl.source_line, e)),
            }
        }
    }

    errors
}

/// Parse Rust from contract file or source files. Returns errors.
fn parse_rust_specs(
    specs: &mut FfiSpecs,
    contract_file: Option<&str>,
    rust_files: &[String],
    verbose: bool,
) -> Vec<String> {
    let mut errors = Vec::new();

    if let Some(contract_path) = contract_file {
        let Ok(content) = fs::read_to_string(contract_path) else {
            errors.push(format!("error reading contract '{contract_path}'"));
            return errors;
        };
        match FfiContractFile::from_json(&content) {
            Ok(contract) => {
                let contract_specs = contract.to_ffi_specs();
                for (name, func) in contract_specs.rust_exports {
                    specs.rust_exports.insert(name, func);
                }
                if verbose {
                    eprintln!(
                        "Loaded {} FFI functions from contract: {}",
                        specs.rust_exports.len(),
                        contract_path
                    );
                }
            }
            Err(e) => errors.push(format!("error parsing contract '{contract_path}': {e}")),
        }
    } else {
        for path in rust_files {
            let Ok(content) = fs::read_to_string(path) else {
                errors.push(format!("error reading '{path}'"));
                continue;
            };
            for decl in parse_rust_ffi_declarations_from_source(&content, path) {
                match rust_decl_to_ffi_function_parsed(&decl) {
                    Ok(ffi_fn) => specs.add(ffi_fn),
                    Err(e) => errors.push(format!("{}:{}: error: {}", path, decl.source_line, e)),
                }
            }
        }
    }

    errors
}

#[allow(clippy::too_many_lines)]
fn main() -> ExitCode {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 || args.iter().any(|a| a == "--help" || a == "-h") {
        print_help();
        return ExitCode::SUCCESS;
    }

    let parsed = match parse_arguments(&args) {
        Ok(p) => p,
        Err(e) => {
            eprintln!("{e}");
            return ExitCode::from(2);
        }
    };

    let has_swift_input = !parsed.swift_files.is_empty() || !parsed.generated_files.is_empty();
    let has_rust_source = !parsed.rust_files.is_empty();
    let has_contract = parsed.contract_file.is_some();

    // --emit-contract mode
    if let Some(output_path) = &parsed.emit_contract {
        if !has_rust_source {
            eprintln!("error: --emit-contract requires --rust source files");
            return ExitCode::from(2);
        }
        return emit_contract_file(
            &parsed.rust_files,
            output_path,
            parsed.crate_name.as_deref(),
        );
    }

    // Validate verify mode inputs
    if !has_swift_input {
        eprintln!("error: no Swift input files specified");
        return ExitCode::from(2);
    }
    if !has_rust_source && !has_contract {
        eprintln!("error: no Rust source specified");
        return ExitCode::from(2);
    }
    if has_rust_source && has_contract {
        eprintln!("warning: both --rust and --ffi-contract specified; using --ffi-contract");
    }

    // Build FfiSpecs
    let mut specs = FfiSpecs::new();
    let mut errors = parse_swift_files(&mut specs, &parsed.swift_files, &parsed.generated_files);
    errors.extend(parse_rust_specs(
        &mut specs,
        parsed.contract_file.as_deref(),
        &parsed.rust_files,
        parsed.verbose,
    ));

    for err in &errors {
        eprintln!("{err}");
    }

    // Run verification
    let options = FfiVerifyOptions {
        use_z4_proofs: parsed.use_z4,
    };
    let results = verify_ffi_compatibility_with_options(&specs, &options);

    if parsed.json_output {
        print_json_results(&results);
    } else {
        print_text_results(&results, parsed.verbose);
    }

    let all_compatible = results
        .iter()
        .all(|r| r.result == FfiCompatibility::Compatible);
    if !errors.is_empty() {
        ExitCode::from(2)
    } else if !all_compatible {
        ExitCode::from(1)
    } else {
        ExitCode::SUCCESS
    }
}

fn print_help() {
    println!(
        r"tswift-ffi-verify - Verify FFI compatibility between Swift and Rust

USAGE:
    tswift-ffi-verify --swift <files...> --rust <files...> [OPTIONS]
    tswift-ffi-verify --swift <files...> --ffi-contract <contract.ffi.json> [OPTIONS]
    tswift-ffi-verify --swift <files...> --ffi-contract=<contract.ffi.json> [OPTIONS]
    tswift-ffi-verify --emit-contract <output.ffi.json> --rust <files...>
    tswift-ffi-verify --emit-ffi-contract <output.ffi.json> --rust <files...>

OPTIONS:
    --swift <files>         Swift source files with @_ffi_* annotations
    --generated <files>     Swift source files generated by swift-bridge
    --rust <files>          Rust source files to parse for FFI exports
    --ffi-contract <file>   Use contract file instead of Rust source (Contract Mode)
    --emit-contract <file>  Generate contract file from Rust FFI exports
    --emit-ffi-contract     Alias for --emit-contract (docs-friendly)
    --crate-name <name>     Crate name for emitted contract (default: from path)
    --z4                    Use Z4 SMT solver for semantic implication proofs
    --json                  Output results as JSON
    --verbose               Show detailed check results
    -h, --help              Show this help message

MODES:
    Unified Mode:  --swift + --rust (full source verification)
    Contract Mode: --swift + --ffi-contract (verify against contract)
    Emit Mode:     --emit-contract + --rust (generate contract file)

EXAMPLES:
    # Unified Mode: Verify Swift against Rust source
    tswift-ffi-verify --swift src/ffi.swift --rust ../rust/src/lib.rs

    # Contract Mode: Verify Swift against pre-generated contract
    tswift-ffi-verify --swift src/ffi.swift --ffi-contract rust-core.ffi.json

    # Emit Mode: Generate contract file from Rust source
    tswift-ffi-verify --emit-contract core.ffi.json --rust src/lib.rs --crate-name my-core

    # Use Z4 for semantic verification
    tswift-ffi-verify --swift *.swift --rust *.rs --z4

    # Output as JSON for CI integration
    tswift-ffi-verify --swift src/*.swift --rust rust/src/*.rs --json

EXIT CODES:
    0   All FFI bindings are compatible / Contract generated
    1   One or more FFI bindings are incompatible
    2   Error (missing files, parse errors, etc.)
"
    );
}

/// Generate a contract file from Rust FFI exports
fn emit_contract_file(
    rust_files: &[String],
    output_path: &str,
    crate_name: Option<&str>,
) -> ExitCode {
    let mut specs = FfiSpecs::new();
    let mut errors: Vec<String> = Vec::new();

    // Parse Rust files
    for path in rust_files {
        let content = match fs::read_to_string(path) {
            Ok(c) => c,
            Err(e) => {
                errors.push(format!("error reading '{path}': {e}"));
                continue;
            }
        };

        let decls = parse_rust_ffi_declarations_from_source(&content, path);
        for decl in decls {
            match rust_decl_to_ffi_function_parsed(&decl) {
                Ok(ffi_fn) => specs.add(ffi_fn),
                Err(e) => {
                    errors.push(format!(
                        "{}:{}: error parsing FFI declaration '{}': {}",
                        path, decl.source_line, decl.rust_name, e
                    ));
                }
            }
        }
    }

    // Report parse errors
    for err in &errors {
        eprintln!("{err}");
    }

    if !errors.is_empty() {
        return ExitCode::from(2);
    }

    if specs.rust_exports.is_empty() {
        eprintln!("warning: no FFI exports found in Rust files");
    }

    // Determine crate name
    let name = crate_name.unwrap_or_else(|| {
        // Extract from first Rust file path
        rust_files
            .first()
            .and_then(|p| std::path::Path::new(p).file_stem())
            .and_then(|s| s.to_str())
            .unwrap_or("unknown")
    });

    // Generate contract
    let contract = ffi_specs_to_contract(&specs, name);

    match contract.to_json() {
        Ok(json) => match fs::write(output_path, &json) {
            Ok(()) => {
                println!(
                    "Generated contract: {} ({} functions)",
                    output_path,
                    specs.rust_exports.len()
                );
                ExitCode::SUCCESS
            }
            Err(e) => {
                eprintln!("error writing contract '{output_path}': {e}");
                ExitCode::from(2)
            }
        },
        Err(e) => {
            eprintln!("error serializing contract: {e}");
            ExitCode::from(2)
        }
    }
}

fn print_text_results(results: &[FfiVerifyResult], verbose: bool) {
    if results.is_empty() {
        println!("No FFI bindings to verify.");
        return;
    }

    let mut compatible = 0;
    let mut incompatible = 0;
    let mut unknown = 0;

    for result in results {
        let status = match result.result {
            FfiCompatibility::Compatible => {
                compatible += 1;
                "OK"
            }
            FfiCompatibility::Incompatible => {
                incompatible += 1;
                "FAIL"
            }
            FfiCompatibility::Unknown => {
                unknown += 1;
                "UNKNOWN"
            }
        };

        println!(
            "[{}] {} ({} -> {})",
            status, result.function_name, result.caller, result.callee
        );

        if verbose || result.result != FfiCompatibility::Compatible {
            for check in &result.checks {
                let check_status = if check.passed { "pass" } else { "FAIL" };
                let msg = check.message.as_deref().unwrap_or("");
                println!("      {} {}: {}", check_status, check.check_type, msg);
            }
        }
    }

    println!();
    println!("Summary: {compatible} compatible, {incompatible} incompatible, {unknown} unknown");
}

fn print_json_results(results: &[FfiVerifyResult]) {
    // Build JSON output manually (avoiding serde_json dependency for simplicity)
    println!("{{");
    println!("  \"results\": [");

    for (i, result) in results.iter().enumerate() {
        let status = match result.result {
            FfiCompatibility::Compatible => "compatible",
            FfiCompatibility::Incompatible => "incompatible",
            FfiCompatibility::Unknown => "unknown",
        };

        println!("    {{");
        println!("      \"function\": \"{}\",", result.function_name);
        println!("      \"caller\": \"{}\",", result.caller);
        println!("      \"callee\": \"{}\",", result.callee);
        println!("      \"status\": \"{status}\",");
        println!("      \"checks\": [");

        for (j, check) in result.checks.iter().enumerate() {
            let msg = check.message.as_deref().unwrap_or("").replace('\"', "\\\"");
            println!("        {{");
            println!("          \"type\": \"{}\",", check.check_type);
            println!("          \"passed\": {},", check.passed);
            println!("          \"message\": \"{msg}\"");
            print!("        }}");
            if j < result.checks.len() - 1 {
                println!(",");
            } else {
                println!();
            }
        }

        println!("      ]");
        print!("    }}");
        if i < results.len() - 1 {
            println!(",");
        } else {
            println!();
        }
    }

    println!("  ],");

    let compatible = results
        .iter()
        .filter(|r| r.result == FfiCompatibility::Compatible)
        .count();
    let incompatible = results
        .iter()
        .filter(|r| r.result == FfiCompatibility::Incompatible)
        .count();
    let unknown = results
        .iter()
        .filter(|r| r.result == FfiCompatibility::Unknown)
        .count();

    println!("  \"summary\": {{");
    println!("    \"total\": {},", results.len());
    println!("    \"compatible\": {compatible},");
    println!("    \"incompatible\": {incompatible},");
    println!("    \"unknown\": {unknown}");
    println!("  }}");
    println!("}}");
}

// Helper functions used only in tests
#[cfg(test)]
mod helpers {
    use super::*;

    /// Split an argument of the form --flag=value
    pub fn split_equals_arg_helper<'a>(arg: &'a str, flag: &str) -> Option<&'a str> {
        arg.strip_prefix(flag)
            .and_then(|rest| rest.strip_prefix('='))
    }

    /// Check if help is requested
    pub fn is_help_requested(args: &[String]) -> bool {
        args.len() < 2 || args.iter().any(|a| a == "--help" || a == "-h")
    }

    /// Count results by compatibility status
    pub fn count_by_status(results: &[FfiVerifyResult]) -> (usize, usize, usize) {
        let compatible = results
            .iter()
            .filter(|r| r.result == FfiCompatibility::Compatible)
            .count();
        let incompatible = results
            .iter()
            .filter(|r| r.result == FfiCompatibility::Incompatible)
            .count();
        let unknown = results
            .iter()
            .filter(|r| r.result == FfiCompatibility::Unknown)
            .count();
        (compatible, incompatible, unknown)
    }

    /// Format a single result status
    pub fn format_status(compat: &FfiCompatibility) -> &'static str {
        match compat {
            FfiCompatibility::Compatible => "OK",
            FfiCompatibility::Incompatible => "FAIL",
            FfiCompatibility::Unknown => "UNKNOWN",
        }
    }

    /// Format a single result status for JSON
    pub fn format_status_json(compat: &FfiCompatibility) -> &'static str {
        match compat {
            FfiCompatibility::Compatible => "compatible",
            FfiCompatibility::Incompatible => "incompatible",
            FfiCompatibility::Unknown => "unknown",
        }
    }

    /// Escape a message string for JSON
    pub fn escape_json_string(s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t")
    }

    /// Build JSON output for results (returns string instead of printing)
    pub fn build_json_output(results: &[FfiVerifyResult]) -> String {
        let mut output = String::new();
        output.push_str("{\n");
        output.push_str("  \"results\": [\n");

        for (i, result) in results.iter().enumerate() {
            let status = format_status_json(&result.result);

            output.push_str("    {\n");
            let _ = writeln!(output, "      \"function\": \"{}\",", result.function_name);
            let _ = writeln!(output, "      \"caller\": \"{}\",", result.caller);
            let _ = writeln!(output, "      \"callee\": \"{}\",", result.callee);
            let _ = writeln!(output, "      \"status\": \"{status}\",");
            output.push_str("      \"checks\": [\n");

            for (j, check) in result.checks.iter().enumerate() {
                let msg = escape_json_string(check.message.as_deref().unwrap_or(""));
                output.push_str("        {\n");
                let _ = writeln!(output, "          \"type\": \"{}\",", check.check_type);
                let _ = writeln!(output, "          \"passed\": {},", check.passed);
                let _ = writeln!(output, "          \"message\": \"{msg}\"");
                output.push_str("        }");
                if j < result.checks.len() - 1 {
                    output.push_str(",\n");
                } else {
                    output.push('\n');
                }
            }

            output.push_str("      ]\n");
            output.push_str("    }");
            if i < results.len() - 1 {
                output.push_str(",\n");
            } else {
                output.push('\n');
            }
        }

        output.push_str("  ],\n");

        let (compatible, incompatible, unknown) = count_by_status(results);

        output.push_str("  \"summary\": {\n");
        let _ = writeln!(output, "    \"total\": {},", results.len());
        let _ = writeln!(output, "    \"compatible\": {compatible},");
        let _ = writeln!(output, "    \"incompatible\": {incompatible},");
        let _ = writeln!(output, "    \"unknown\": {unknown}");
        output.push_str("  }\n");
        output.push('}');

        output
    }

    /// Build text summary for results
    pub fn build_text_summary(results: &[FfiVerifyResult]) -> String {
        let (compatible, incompatible, unknown) = count_by_status(results);
        format!("Summary: {compatible} compatible, {incompatible} incompatible, {unknown} unknown")
    }
}

#[cfg(test)]
mod tests {
    use super::helpers::*;
    use super::*;
    use vc_ir_swift::{FfiCheck, FfiCheckType};

    // ============================================================
    // split_equals_arg_helper tests
    // ============================================================

    #[test]
    fn test_split_equals_arg_helper_basic() {
        let result = split_equals_arg_helper("--ffi-contract=path.json", "--ffi-contract");
        assert_eq!(result, Some("path.json"));
    }

    #[test]
    fn test_split_equals_arg_helper_empty_value() {
        let result = split_equals_arg_helper("--ffi-contract=", "--ffi-contract");
        assert_eq!(result, Some(""));
    }

    #[test]
    fn test_split_equals_arg_helper_no_equals() {
        let result = split_equals_arg_helper("--ffi-contract", "--ffi-contract");
        assert_eq!(result, None);
    }

    #[test]
    fn test_split_equals_arg_helper_wrong_flag() {
        let result = split_equals_arg_helper("--emit-contract=path.json", "--ffi-contract");
        assert_eq!(result, None);
    }

    #[test]
    fn test_split_equals_arg_helper_with_path() {
        let result =
            split_equals_arg_helper("--emit-contract=/path/to/file.json", "--emit-contract");
        assert_eq!(result, Some("/path/to/file.json"));
    }

    #[test]
    fn test_split_equals_arg_helper_crate_name() {
        let result = split_equals_arg_helper("--crate-name=my-crate", "--crate-name");
        assert_eq!(result, Some("my-crate"));
    }

    // ============================================================
    // is_help_requested tests
    // ============================================================

    #[test]
    fn test_is_help_requested_no_args() {
        let args = vec!["tswift-ffi-verify".to_string()];
        assert!(is_help_requested(&args));
    }

    #[test]
    fn test_is_help_requested_with_help_flag() {
        let args = vec!["tswift-ffi-verify".to_string(), "--help".to_string()];
        assert!(is_help_requested(&args));
    }

    #[test]
    fn test_is_help_requested_with_h_flag() {
        let args = vec!["tswift-ffi-verify".to_string(), "-h".to_string()];
        assert!(is_help_requested(&args));
    }

    #[test]
    fn test_is_help_requested_with_options() {
        let args = vec![
            "tswift-ffi-verify".to_string(),
            "--swift".to_string(),
            "file.swift".to_string(),
        ];
        assert!(!is_help_requested(&args));
    }

    #[test]
    fn test_is_help_requested_help_in_middle() {
        let args = vec![
            "tswift-ffi-verify".to_string(),
            "--swift".to_string(),
            "--help".to_string(),
        ];
        assert!(is_help_requested(&args));
    }

    // ============================================================
    // count_by_status tests
    // ============================================================

    #[test]
    fn test_count_by_status_empty() {
        let results: Vec<FfiVerifyResult> = vec![];
        let (c, i, u) = count_by_status(&results);
        assert_eq!((c, i, u), (0, 0, 0));
    }

    #[test]
    fn test_count_by_status_all_compatible() {
        let results = vec![
            FfiVerifyResult {
                function_name: "func1".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Compatible,
                checks: vec![],
            },
            FfiVerifyResult {
                function_name: "func2".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Compatible,
                checks: vec![],
            },
        ];
        let (c, i, u) = count_by_status(&results);
        assert_eq!((c, i, u), (2, 0, 0));
    }

    #[test]
    fn test_count_by_status_mixed() {
        let results = vec![
            FfiVerifyResult {
                function_name: "func1".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Compatible,
                checks: vec![],
            },
            FfiVerifyResult {
                function_name: "func2".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Incompatible,
                checks: vec![],
            },
            FfiVerifyResult {
                function_name: "func3".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Unknown,
                checks: vec![],
            },
        ];
        let (c, i, u) = count_by_status(&results);
        assert_eq!((c, i, u), (1, 1, 1));
    }

    // ============================================================
    // format_status tests
    // ============================================================

    #[test]
    fn test_format_status_compatible() {
        assert_eq!(format_status(&FfiCompatibility::Compatible), "OK");
    }

    #[test]
    fn test_format_status_incompatible() {
        assert_eq!(format_status(&FfiCompatibility::Incompatible), "FAIL");
    }

    #[test]
    fn test_format_status_unknown() {
        assert_eq!(format_status(&FfiCompatibility::Unknown), "UNKNOWN");
    }

    // ============================================================
    // format_status_json tests
    // ============================================================

    #[test]
    fn test_format_status_json_compatible() {
        assert_eq!(
            format_status_json(&FfiCompatibility::Compatible),
            "compatible"
        );
    }

    #[test]
    fn test_format_status_json_incompatible() {
        assert_eq!(
            format_status_json(&FfiCompatibility::Incompatible),
            "incompatible"
        );
    }

    #[test]
    fn test_format_status_json_unknown() {
        assert_eq!(format_status_json(&FfiCompatibility::Unknown), "unknown");
    }

    // ============================================================
    // escape_json_string tests
    // ============================================================

    #[test]
    fn test_escape_json_string_empty() {
        assert_eq!(escape_json_string(""), "");
    }

    #[test]
    fn test_escape_json_string_no_escaping() {
        assert_eq!(escape_json_string("hello world"), "hello world");
    }

    #[test]
    fn test_escape_json_string_quotes() {
        assert_eq!(escape_json_string("say \"hello\""), "say \\\"hello\\\"");
    }

    #[test]
    fn test_escape_json_string_backslash() {
        assert_eq!(escape_json_string("path\\to\\file"), "path\\\\to\\\\file");
    }

    #[test]
    fn test_escape_json_string_newline() {
        assert_eq!(escape_json_string("line1\nline2"), "line1\\nline2");
    }

    #[test]
    fn test_escape_json_string_tab() {
        assert_eq!(escape_json_string("col1\tcol2"), "col1\\tcol2");
    }

    #[test]
    fn test_escape_json_string_carriage_return() {
        assert_eq!(escape_json_string("line1\rline2"), "line1\\rline2");
    }

    #[test]
    fn test_escape_json_string_mixed() {
        assert_eq!(
            escape_json_string("\"test\"\n\\path"),
            "\\\"test\\\"\\n\\\\path"
        );
    }

    // ============================================================
    // build_text_summary tests
    // ============================================================

    #[test]
    fn test_build_text_summary_empty() {
        let results: Vec<FfiVerifyResult> = vec![];
        let summary = build_text_summary(&results);
        assert_eq!(summary, "Summary: 0 compatible, 0 incompatible, 0 unknown");
    }

    #[test]
    fn test_build_text_summary_all_ok() {
        let results = vec![FfiVerifyResult {
            function_name: "func".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![],
        }];
        let summary = build_text_summary(&results);
        assert_eq!(summary, "Summary: 1 compatible, 0 incompatible, 0 unknown");
    }

    #[test]
    fn test_build_text_summary_mixed() {
        let results = vec![
            FfiVerifyResult {
                function_name: "func1".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Compatible,
                checks: vec![],
            },
            FfiVerifyResult {
                function_name: "func2".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Incompatible,
                checks: vec![],
            },
        ];
        let summary = build_text_summary(&results);
        assert_eq!(summary, "Summary: 1 compatible, 1 incompatible, 0 unknown");
    }

    // ============================================================
    // build_json_output tests
    // ============================================================

    #[test]
    fn test_build_json_output_empty() {
        let results: Vec<FfiVerifyResult> = vec![];
        let json = build_json_output(&results);
        // Empty results array has newlines between brackets
        assert!(json.contains("\"results\": ["));
        assert!(json.contains("  ],"));
        assert!(json.contains("\"total\": 0"));
        assert!(json.contains("\"compatible\": 0"));
    }

    #[test]
    fn test_build_json_output_single_result() {
        let results = vec![FfiVerifyResult {
            function_name: "testFunc".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"function\": \"testFunc\""));
        assert!(json.contains("\"status\": \"compatible\""));
        assert!(json.contains("\"total\": 1"));
    }

    #[test]
    fn test_build_json_output_with_checks() {
        let results = vec![FfiVerifyResult {
            function_name: "add".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![FfiCheck {
                check_type: FfiCheckType::TypeLayout,
                passed: true,
                message: Some("Types match".to_string()),
            }],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"type\": \"type layout\""));
        assert!(json.contains("\"passed\": true"));
        assert!(json.contains("\"message\": \"Types match\""));
    }

    #[test]
    fn test_build_json_output_multiple_results() {
        let results = vec![
            FfiVerifyResult {
                function_name: "func1".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Compatible,
                checks: vec![],
            },
            FfiVerifyResult {
                function_name: "func2".to_string(),
                caller: FfiLanguage::Swift,
                callee: FfiLanguage::Rust,
                result: FfiCompatibility::Incompatible,
                checks: vec![],
            },
        ];
        let json = build_json_output(&results);
        assert!(json.contains("\"function\": \"func1\""));
        assert!(json.contains("\"function\": \"func2\""));
        assert!(json.contains("\"total\": 2"));
        assert!(json.contains("\"compatible\": 1"));
        assert!(json.contains("\"incompatible\": 1"));
    }

    #[test]
    fn test_build_json_output_escapes_special_chars() {
        let results = vec![FfiVerifyResult {
            function_name: "test".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Incompatible,
            checks: vec![FfiCheck {
                check_type: FfiCheckType::TypeLayout,
                passed: false,
                message: Some("Error: \"quotes\" and\nnewlines".to_string()),
            }],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\\\"quotes\\\""));
        assert!(json.contains("\\n"));
    }

    #[test]
    fn test_build_json_output_caller_callee() {
        let results = vec![FfiVerifyResult {
            function_name: "func".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"caller\": \"Swift\""));
        assert!(json.contains("\"callee\": \"Rust\""));
    }

    #[test]
    fn test_build_json_output_unknown_status() {
        let results = vec![FfiVerifyResult {
            function_name: "func".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Unknown,
            checks: vec![],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"status\": \"unknown\""));
        assert!(json.contains("\"unknown\": 1"));
    }

    #[test]
    fn test_build_json_output_empty_message() {
        let results = vec![FfiVerifyResult {
            function_name: "func".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![FfiCheck {
                check_type: FfiCheckType::Ownership,
                passed: true,
                message: None,
            }],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"message\": \"\""));
    }

    #[test]
    fn test_build_json_output_multiple_checks() {
        let results = vec![FfiVerifyResult {
            function_name: "func".to_string(),
            caller: FfiLanguage::Swift,
            callee: FfiLanguage::Rust,
            result: FfiCompatibility::Compatible,
            checks: vec![
                FfiCheck {
                    check_type: FfiCheckType::TypeLayout,
                    passed: true,
                    message: Some("OK".to_string()),
                },
                FfiCheck {
                    check_type: FfiCheckType::PreconditionCompatibility,
                    passed: true,
                    message: Some("Verified".to_string()),
                },
            ],
        }];
        let json = build_json_output(&results);
        assert!(json.contains("\"type\": \"type layout\""));
        assert!(json.contains("\"type\": \"precondition\""));
    }
}
